
%{

#include <iostream>
#include <sstream>
#include <fstream>
#include <cstdlib>
#include <string>
#include <unordered_map>
#include <map>
#include <vector>
#include <cmath>
#include <complex>

#include <Teuchos_RCP.hpp>

#include "location.hh"
#include "ExpressionType.h"
#include "ast.h"
#include "newExpression.h"

namespace Xyce {
namespace Util {
class ExpressionLexer;
}}

%}

%skeleton "lalr1.cc"
%parse-param {Xyce::Util::ExpressionLexer *theLexer}
%parse-param {Xyce::Util::newExpression & newExp}
%lex-param {Xyce::Util::ExpressionLexer *theLexer}

%define parser_class_name "ExpressionParser"
%locations
%defines

%name-prefix="XyceExpression"
%require "3.2"

// ERK:  4/22/2020.  Below, in the union I am using pointers to RCP's.
// I needed to use RCP's because expressions in Xyce get copied all
// over the place, and rather than create copy constructors for the
// entire AST tree, it is much easier to just copy
// over the RCP (kind of like a what happens in a move constructor).
//
// The pointers are used b/c the union below only supports basic data
// types like int, double, etc.  And pointers.
//
// However, it turns out that the C++ version of Bison has something called
// Variants.  They are documented for Bison 3.5 here:
//
//  http://www.gnu.org/software/bison/manual/bison.html#C_002b_002b-Variants
//
// I had not realized that when I wrote the code, below.  Variants
// are an alternative to the union, and permit other sorts of data types
// include STL, etc.  So I probably could have used RCP's without 
// having to use pointers to them.  This could be a future refactor.

%union
{
  Teuchos::RCP<astNode<usedType> > * astNodePtr;
  std::vector< Teuchos::RCP<astNode<usedType> > > * nodeVecPtr;

  int ival;
  double dval;
  std::string *sval;
  std::vector<std::string> *vecsval;
  std::vector<int> *vecival;
};

%{
  // WARNING!!!!  The stuff in this block is the "post-prologue" that
  // in versions of Bison prior to 2.3 used to be placed into the .hxx
  // file generated by bison, and which we could therefore just include
  // to get the right stuff.
  // In version 2.3 they stopped doing that and started putting the
  // post-prologue code directly into the generated .cxx file, which means
  // that we need to DUPLICATE this block of code in N_DEV_ReactionNetwork.C.
  // If you change *ANYTHING* in this post-prologue, you MUST edit
  // N_DEV_ReactionNetwork.C and keep it in sync with the changes in this
  // block!
  // Note also that this was absolutely critical to do in Bison 2.3, and
  // somehow didn't seem to matter much just a few releases of bison later.
  // Careless hacking of this block *could* break compatibility of Xyce with
  // older versions of Bison and go unnoticed in testing.  Please be careful.
#undef yyFlexLexer
  /* CAREFUL watch continuations! */
#define YY_DECL \
int ExpressionLexer::getToken(ExpressionParser::semantic_type *lvalp,  \
                            location *llocp)

  // YECH!  Work around very stupid way that multiple parsers/lexers are
  // handled.
  // Bison's "%name-prefix" is implemented as a #define yylex "prefix"lex
  // which BREAKS flex's C++ lexer: it contains a method "yylex" in the
  // yyFlexLexer class.  Unless we do this kludge, that method gets renamed
  // with the define as well, and the result is a broken set of classes
#undef yylex
#include <FlexLexer.h>
#include "ExpressionLexer.h"
  // undo that kludge.  Note that because of this stupidity, if the
  // "%name-prefix" is changed, this line needs to be changed, too.
#define yylex XyceExpressionlex

int XyceExpressionlex(XyceExpression::ExpressionParser::semantic_type *lvalp, XyceExpression::location *locp,
             Xyce::Util::ExpressionLexer *theLexer);


// fix this later
bool checkGroundNodeName(std::string & name)
{
  std::string tmpName = name;
  Xyce::Util::toUpper(tmpName);

  if (tmpName == std::string("0")) { return true; }
  if (tmpName == std::string("GND")) { return true; }

  bool thisIsNotGround=true;
  if (tmpName.size() > 1)
  {
    int last = tmpName.size()-1;
    std::string endOfName = tmpName.substr(last-1,last);
    if (endOfName == ":0") { thisIsNotGround=false; }
  }
  if (!thisIsNotGround) { return true; }

  return false;
}

%}

// value tokens from the lexer (ExpressionLexer.l)
%token <dval> TOK_POLYSIZE	"polysize"
%token <dval> TOK_POLYCOEF "polycoef"
%token <dval> TOK_NUM	"num"
%token <sval> TOK_WORD "word"
%token <sval> TOK_LEAD "lead"
%token <sval> TOK_ONOISE "onoise"
%token <sval> TOK_INOISE "inoise"
%token <sval> TOK_POWER "power"
%token <sval> TOK_VOLTAGENODE "voltagenode"
%token <sval> TOK_CURRENTDEV "currentdevice"
%token <sval> TOK_INTERNAL_DEV_VAR "internal_device_variable"
%token <sval> TOK_NOISE_DEV_VAR "noise_device_variable"
%token <ival> TOK_RFPARAM_ARG "rf_param_arg"

// non-value tokens from the lexer (ExpressionLexer.l)
%token TOK_SQRT	"sqrt"
%token TOK_MAX	"max"
%token TOK_MIN	"min"
%token TOK_PHASE	"phase"
%token TOK_REAL	"real"
%token TOK_IMAG	"imag"
%token TOK_EXP	"exp"
%token TOK_SIN	"sin"
%token TOK_COS	"cos"
%token TOK_MABS	"m"
%token TOK_ABS	"abs"
%token TOK_ACOS	"acos"
%token TOK_ACOSH	"acosh"
%token TOK_ASIN	"asin"
%token TOK_ASINH	"asinh"
%token TOK_ATAN2	"atan2"
%token TOK_ATAN	"atan"
%token TOK_ATANH	"atanh"
%token TOK_COSH	"cosh"
%token TOK_LN	"ln"
%token TOK_LOG	"log"
%token TOK_LOG10	"log10"
%token TOK_SINH	"sinh"
%token TOK_TAN	"tan"
%token TOK_TANH	"tanh"
%token TOK_IF "if"

%token TOK_AUNIF	"aunif"
%token TOK_UNIF	"unif"
%token TOK_AGAUSS	"agauss"
%token TOK_CEIL	"ceil"
%token TOK_GAUSS	"gauss"
%token TOK_DDT	"ddt"
%token TOK_DDX	"ddx"
%token TOK_FLOOR	"floor"
%token TOK_INT 	"int"
%token TOK_LIMIT 	"limit"
%token TOK_POWSFUNC 	"pwrs"
%token TOK_RAND	"rand"
%token TOK_SDT	"sdt"
%token TOK_SGN	"sgn"
%token TOK_SIGN	"sign"
%token TOK_STP	"stp"
%token TOK_TABLE	"table"
%token TOK_SCHEDULE	"schedule"
%token TOK_URAMP	"uramp"
%token TOK_POLY	"poly"

%token TOK_SPICE_PULSE "spice_pulse"
%token TOK_SPICE_SIN "spice_sin"
%token TOK_SPICE_EXP "spice_exp"
%token TOK_SPICE_SFFM "spice_sffm"

%token TOK_TIME  "time"
%token TOK_TEMP  "temp"
%token TOK_VT    "vt"
%token TOK_FREQ  "freq"
%token TOK_GMIN  "gmin"
%token TOK_PI    "pi"
%token TOK_C_TO_K    "CtoK"

%token TOK_RIGHTPAREN "rightparen"
%token TOK_LEFTPAREN  "leftparen"
%token TOK_RIGHTCURLYBRACE "rightcurlybrace"
%token TOK_LEFTCURLYBRACE  "leftcurlybrace"

// types for nonterminal operators
%type  <astNodePtr>   exp
%type  <astNodePtr>   expression
%type  <nodeVecPtr>   nonempty_arglist
%type  <nodeVecPtr>   nonempty_arg_pairs
%type  <nodeVecPtr>   no_comma_arglist
%type  <nodeVecPtr>   no_comma_coeflist
%type  <vecsval>  nonempty_voltagenodelist
%type  <vecival>  nonempty_rfparam_arg_list
%type  <vecsval>  nonempty_noise_device_list
%type  <dval>  paren_polycoef

%destructor { delete $$; } TOK_WORD
%destructor { delete $$; } TOK_LEAD
%destructor { delete $$; } TOK_VOLTAGENODE
%destructor { delete $$; } TOK_CURRENTDEV
%destructor { delete $$; } TOK_INTERNAL_DEV_VAR
%destructor { delete $$; } TOK_NOISE_DEV_VAR
%destructor { delete $$; } TOK_ONOISE
%destructor { delete $$; } TOK_INOISE
%destructor { delete $$; } TOK_POWER
%destructor { delete $$; } nonempty_voltagenodelist
%destructor { delete $$; } nonempty_rfparam_arg_list
%destructor { delete $$; } nonempty_noise_device_list


// Operator Precedence tokens
%left   ','
%right  '?' ':'
%left  TOK_OR "||" TOK_AND "&&"
%left  TOK_NOT "~"
%left  TOK_XOR "^"
%left  TOK_EQ	"==" TOK_NE	"!=" TOK_LE	"<=" TOK_LT	"<" TOK_GE	">=" TOK_GT	">"
%left   '-' '+'
%left   '%'
%left   '*' '/'
%left   NEG '!'  /* negation--unary minus, and boolean not */
%right   TOK_POW  TOK_POWFUNC  /* exponentiation */

%%
expression: exp
  {
      if (yynerrs_ != 0)
      {
        YYABORT;
      }
      else
      {
        newExp.setAstPtr(*$1);

        YYACCEPT;
      }
 }

exp:
    TOK_NUM
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new numval<usedType>($1));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_NUM 'J'
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new numval<usedType>(std::complex<basicType>(0.0,$1)));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }

  | TOK_WORD
      {
        // ensures that each parameter and/or function argument  has a single, unique astNode allocated for it
        //
        // note that maps are not used here, intentionally, so as to preseve the original order of params.
        // using a std::vector for the names and a separate vector for the paramOps keeps them in order user specified.
        std::vector<std::string> & paramNameVec = newExp.getParamNameVec ();
        std::vector<Teuchos::RCP<astNode<usedType> > > & paramOpVec = newExp.getParamOpVec ();
        std::vector<std::string>::iterator nameIter = std::find(paramNameVec.begin(),paramNameVec.end(), *$1);
        if ( nameIter == paramNameVec.end() )
        {
          Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new paramOp<usedType>(*$1));
          paramOpVec.push_back(*tmpPtr);
          paramNameVec.push_back(*$1);
          Teuchos::RCP<astNode<usedType> > * tmpPtr2 = new Teuchos::RCP<astNode<usedType> >(*tmpPtr);
          newExp.getMasterNodeVec().push_back(tmpPtr2);

          $$ = tmpPtr2;
          delete tmpPtr;
        }
        else
        {
          int index = std::distance(paramNameVec.begin(),nameIter);
          Teuchos::RCP<astNode<usedType> > * tmpPtr2 = new Teuchos::RCP<astNode<usedType> >(paramOpVec[index]);
          newExp.getMasterNodeVec().push_back(tmpPtr2);
          $$ = tmpPtr2;
        }
        delete $1;
    }
  | TOK_TIME
    {
      Teuchos::RCP<astNode<usedType> > tmp = newExp.getTimeNode ();
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(tmp);
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
      newExp.setTimeDependent(true);
    }
  | TOK_TEMP
    {
      Teuchos::RCP<astNode<usedType> > tmp =newExp.getTempNode ();
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(tmp);
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
      newExp.setTempDependent(true);
    }
  | TOK_VT
    {
      Teuchos::RCP<astNode<usedType> > tmp = newExp.getVtNode ();
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(tmp);
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
      newExp.setVTDependent(true);
    }
  | TOK_FREQ
    {
      Teuchos::RCP<astNode<usedType> > tmp = newExp.getFreqNode ();
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(tmp);
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
      newExp.setFreqDependent(true);
    }
  | TOK_GMIN
    {
      Teuchos::RCP<astNode<usedType> > tmp = newExp.getGminNode ();
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(tmp);
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
      newExp.setGminDependent(true);
    }
  | TOK_PI
    {
      Teuchos::RCP<astNode<usedType> > tmp = newExp.getPiNode ();
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(tmp);
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_C_TO_K
    {
      Teuchos::RCP<astNode<usedType> > tmp = newExp.getCtoKNode ();
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(tmp);
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | exp '+' exp
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new binaryAddOp<usedType>  (*$1,*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | exp '-' exp
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new binaryMinusOp<usedType>  (*$1,*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | exp '*' exp
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new binaryMulOp<usedType>  (*$1,*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | exp '/' exp
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new binaryDivOp<usedType>  (*$1,*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | exp '%' exp
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new binaryModOp<usedType>  (*$1,*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | exp TOK_POW exp
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new powOp<usedType>  (*$1,*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
   | TOK_POWFUNC TOK_LEFTPAREN exp ',' exp TOK_RIGHTPAREN 
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new powOp<usedType>  (*$3,*$5));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_POWSFUNC TOK_LEFTPAREN exp ',' exp TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new pwrsOp<usedType>  (*$3,*$5));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_LEFTPAREN exp TOK_RIGHTPAREN
    {
       $$ = $2;
    }
  | TOK_LEFTCURLYBRACE exp TOK_RIGHTCURLYBRACE
    {
       $$ = $2;
    }
  | '~' exp
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new unaryNotOp<usedType>(*$2));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | '-' exp  %prec NEG
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new unaryMinusOp<usedType>(*$2));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | '+' exp
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new unaryPlusOp<usedType>(*$2));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_SGN TOK_LEFTPAREN exp TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new sgnOp<usedType>(*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_SIGN TOK_LEFTPAREN exp ',' exp TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new signOp<usedType>(*$3,*$5));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_WORD TOK_LEFTPAREN nonempty_arglist TOK_RIGHTPAREN
     {
        Teuchos::RCP<funcOp<usedType> > funcPtr = Teuchos::rcp(new funcOp<usedType>(*$1,$3));
        newExp.getFuncOpVec().push_back(funcPtr);
        newExp.getFuncNameVec().push_back(*$1);

        std::unordered_map<std::string,std::vector<Teuchos::RCP<astNode<usedType> > > > & funcOpMap 
          = newExp.getFuncOpMap();

        Teuchos::RCP<astNode<usedType> > * tmpPtr2 = new Teuchos::RCP<astNode<usedType> >(funcPtr); // implicit cast
        newExp.getMasterNodeVec().push_back(tmpPtr2);

        if (funcOpMap.find(*$1) == funcOpMap.end())
        {
          std::vector<Teuchos::RCP<astNode<usedType> > > vec;//(1,tmpPtr2);
          vec.push_back(*tmpPtr2);
          funcOpMap[*$1] = vec;
        }
        else
        {
          funcOpMap[*$1].push_back(*tmpPtr2);
        }

        $$ = tmpPtr2;
        delete $1;
        delete $3;
    }
  | TOK_WORD nonempty_voltagenodelist
    {
      std::vector<std::string> voltageNodes = *$2; 
      Teuchos::RCP<astNode<usedType> > * tmpPtr;
      Teuchos::RCP<astNode<usedType> > * returnPtr;
      if (voltageNodes.size() == 1)
      {
        if ( !checkGroundNodeName((*$2)[0]) )
        {
          Teuchos::RCP<voltageOp<usedType> > * voltPtr = new Teuchos::RCP<voltageOp<usedType> >(new voltageOp<usedType>(*$2));
          tmpPtr = new Teuchos::RCP<astNode<usedType> >(*voltPtr);
          newExp.getVoltOpVec ().push_back(*voltPtr);
          delete voltPtr;
        }
        else
        {
          Teuchos::RCP<astNode<usedType> > *voltPtr = new Teuchos::RCP<astNode<usedType> >(new numval<usedType>(0.0));
          tmpPtr = new Teuchos::RCP<astNode<usedType> >(*voltPtr);
          delete voltPtr;
        }
        newExp.getMasterNodeVec().push_back(tmpPtr);
      }
      // this was not the original plan for V(A,B), but it seemed like the easiest way to 
      // handle derivative indexing. Instead of having the voltageOp class handle the differencing, 
      // I instead create two voltage nodes, one for V(A) and one for V(B) and then
      // pass them as arguments to a binaryMinusOp operator.
      else if (voltageNodes.size() == 2) 
      {
        Teuchos::RCP<astNode<usedType> > * tmp1Ptr;
        Teuchos::RCP<astNode<usedType> > * tmp2Ptr;

        if ( !checkGroundNodeName( voltageNodes[0]) )
        {
          std::vector<std::string> nodes1;
          nodes1.push_back(voltageNodes[0]);
          Teuchos::RCP<voltageOp<usedType> > * volt1Ptr = new Teuchos::RCP<voltageOp<usedType> >(new voltageOp<usedType>(nodes1));
          tmp1Ptr = new Teuchos::RCP<astNode<usedType> >(*volt1Ptr);
          newExp.getVoltOpVec ().push_back(*volt1Ptr);
          delete volt1Ptr;
        }
        else
        {
          Teuchos::RCP<astNode<usedType> > *voltPtr = new Teuchos::RCP<astNode<usedType> >(new numval<usedType>(0.0));
          tmp1Ptr = new Teuchos::RCP<astNode<usedType> >(*voltPtr);
          delete voltPtr;
        }

        if ( !checkGroundNodeName( voltageNodes[1]) )
        {
          std::vector<std::string> nodes2;
          nodes2.push_back(voltageNodes[1]);
          Teuchos::RCP<voltageOp<usedType> > * volt2Ptr = new Teuchos::RCP<voltageOp<usedType> >(new voltageOp<usedType>(nodes2));
          tmp2Ptr = new Teuchos::RCP<astNode<usedType> >(*volt2Ptr);
          newExp.getVoltOpVec ().push_back(*volt2Ptr);
          delete volt2Ptr;
        }
        else
        {
          Teuchos::RCP<astNode<usedType> > *voltPtr = new Teuchos::RCP<astNode<usedType> >(new numval<usedType>(0.0));
          tmp2Ptr = new Teuchos::RCP<astNode<usedType> >(*voltPtr);
          delete voltPtr;
        }

        tmpPtr = new Teuchos::RCP<astNode<usedType> >(new binaryMinusOp<usedType>  (*tmp1Ptr,*tmp2Ptr));
        newExp.getMasterNodeVec().push_back(tmp1Ptr);
        newExp.getMasterNodeVec().push_back(tmp2Ptr);
        newExp.getMasterNodeVec().push_back(tmpPtr);
      }

      // adjust for complex number variants
      // remove whitespace from the first argument
      std::string firstArg = (*$1);
      firstArg.erase(std::remove_if(firstArg.begin(),firstArg.end(), ::isspace), firstArg.end());
      if (firstArg.size() == 1)
      {
        returnPtr = tmpPtr;
      }
      else if (firstArg.size() == 2)
      {
         if ( firstArg == std::string("VR") )
         {
           returnPtr = new Teuchos::RCP<astNode<usedType> >(new realOp<usedType>(*tmpPtr));
           newExp.getMasterNodeVec().push_back(returnPtr);
         }
         else if ( firstArg == std::string("VI") )
         {
           returnPtr = new Teuchos::RCP<astNode<usedType> >(new imagOp<usedType>(*tmpPtr));
           newExp.getMasterNodeVec().push_back(returnPtr);
         }
         else if ( firstArg == std::string("VM") )
         {
           returnPtr = new Teuchos::RCP<astNode<usedType> >(new absOp<usedType>(*tmpPtr));
           newExp.getMasterNodeVec().push_back(returnPtr);
         }
         else if ( firstArg == std::string("VP") )
         {
           returnPtr = new Teuchos::RCP<astNode<usedType> >(new phaseOp<usedType>(*tmpPtr));
           newExp.getMasterNodeVec().push_back(returnPtr);
           newExp.getPhaseOpVec().push_back(*returnPtr);
         }
      }
      else if (firstArg.size() == 3) // do decibels here
      {
        if ( firstArg == std::string("VDB") )
        {
          // this needs to implement 20.0*std::log10(abs(*tmpPtr))  
          Teuchos::RCP<astNode<usedType> > * numvalPtr = new Teuchos::RCP<astNode<usedType> >(new numval<usedType> (20.0));
          Teuchos::RCP<astNode<usedType> > * absPtr = new Teuchos::RCP<astNode<usedType> >(new absOp<usedType>(*tmpPtr));
          Teuchos::RCP<astNode<usedType> > * log10Ptr = new Teuchos::RCP<astNode<usedType> >(new log10Op<usedType>(*absPtr));
          returnPtr = new Teuchos::RCP<astNode<usedType> >(new binaryMulOp<usedType>  (*numvalPtr,*log10Ptr));

          newExp.getMasterNodeVec().push_back(numvalPtr);
          newExp.getMasterNodeVec().push_back(absPtr);
          newExp.getMasterNodeVec().push_back(log10Ptr);
          newExp.getMasterNodeVec().push_back(returnPtr);
        }
      }
      else
      {
        std::cout << "Unrecognized voltage operator " << firstArg << std::endl;
      }

      $$ = returnPtr;
      delete $1;
      delete $2;
    }
  | TOK_WORD TOK_CURRENTDEV
    {
      Teuchos::RCP<astNode<usedType> > * returnPtr;

      std::string deviceName = (*$2);

      if ( !(deviceName.empty()) && ( deviceName[0] == 'X' ))// inside a subcircuit.  So, for the logic below, need to strip out everything until the last ":"
      {
        std::size_t found = deviceName.find_last_of(":");
        if ( found != std::string::npos) { deviceName = deviceName.substr(found+1); }
      }

      if ( !(deviceName.empty()) && ( 
            deviceName[0] == 'V' || 
            deviceName[0] == 'B' || 
            deviceName[0] == 'E' || 
            deviceName[0] == 'H' || 
            deviceName[0] == 'L' )) // solution variable current
      {
        Teuchos::RCP<currentOp<usedType> > * currentPtr = new Teuchos::RCP<currentOp<usedType> >(new currentOp<usedType>(*$2));
        Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(*currentPtr);
        newExp.getMasterNodeVec().push_back(tmpPtr);
        newExp.getCurrentOpVec().push_back(*currentPtr);

        // adjust for complex number variants
        std::string firstArg = (*$1);
        firstArg.erase(std::remove_if(firstArg.begin(),firstArg.end(), ::isspace), firstArg.end());
        if (firstArg.size() == 1)
        {
          returnPtr = tmpPtr;
        }
        else if (firstArg.size() == 2)
        {
           if ( firstArg == std::string("IR") )
           {
             returnPtr = new Teuchos::RCP<astNode<usedType> >(new realOp<usedType>(*tmpPtr));
             newExp.getMasterNodeVec().push_back(returnPtr);
           }
           else if ( firstArg == std::string("II") )
           {
             returnPtr = new Teuchos::RCP<astNode<usedType> >(new imagOp<usedType>(*tmpPtr));
             newExp.getMasterNodeVec().push_back(returnPtr);
           }
           else if ( firstArg == std::string("IM") )
           {
             returnPtr = new Teuchos::RCP<astNode<usedType> >(new absOp<usedType>(*tmpPtr));
             newExp.getMasterNodeVec().push_back(returnPtr);
           }
           else if ( firstArg == std::string("IP") )
           {
             returnPtr = new Teuchos::RCP<astNode<usedType> >(new phaseOp<usedType>(*tmpPtr));
             newExp.getMasterNodeVec().push_back(returnPtr);
             newExp.getPhaseOpVec().push_back(*returnPtr);
           }
        }
        else if (firstArg.size() == 3) // do decibels here
        {
          if ( firstArg == std::string("IDB") )
          {
            // this needs to implement 20.0*std::log10(abs(*tmpPtr))  
            Teuchos::RCP<astNode<usedType> > * numvalPtr = new Teuchos::RCP<astNode<usedType> >(new numval<usedType> (20.0));
            Teuchos::RCP<astNode<usedType> > * absPtr = new Teuchos::RCP<astNode<usedType> >(new absOp<usedType>(*tmpPtr));
            Teuchos::RCP<astNode<usedType> > * log10Ptr = new Teuchos::RCP<astNode<usedType> >(new log10Op<usedType>(*absPtr));
            returnPtr = new Teuchos::RCP<astNode<usedType> >(new binaryMulOp<usedType>  (*numvalPtr,*log10Ptr));

            newExp.getMasterNodeVec().push_back(numvalPtr);
            newExp.getMasterNodeVec().push_back(absPtr);
            newExp.getMasterNodeVec().push_back(log10Ptr);
            newExp.getMasterNodeVec().push_back(returnPtr);
          }
        }
        else
        {
          std::cout << "Unrecognized current operator " << firstArg << std::endl;
        }

        $$ = returnPtr;
        delete currentPtr;
        delete $1;
        delete $2;
      }
      else // lead current
      {
        Teuchos::RCP<leadCurrentOp<usedType> > * leadCurrentPtr = new Teuchos::RCP<leadCurrentOp<usedType> >(new leadCurrentOp<usedType>(*$1,*$2));
        Teuchos::RCP<astNode<usedType> > * returnPtr = new Teuchos::RCP<astNode<usedType> >(*leadCurrentPtr);
        newExp.getLeadCurrentOpVec().push_back(*leadCurrentPtr);
        newExp.getMasterNodeVec().push_back(returnPtr);
        $$ = returnPtr;
        delete leadCurrentPtr;
        delete $1;
        delete $2;
      }
    }
  | TOK_WORD nonempty_rfparam_arg_list
    {
      std::string firstArg = (*$1);
      firstArg.erase(std::remove_if(firstArg.begin(),firstArg.end(), ::isspace), firstArg.end());

      std::vector<int> sparamIndices = *$2; 
      Teuchos::RCP<astNode<usedType> > * tmpPtr;
      Teuchos::RCP<astNode<usedType> > * returnPtr;
      if (sparamIndices.size() == 2)
      {
        if (firstArg[0] == 'S')
        {
          Teuchos::RCP<sparamOp<usedType> > * sparPtr = new Teuchos::RCP<sparamOp<usedType> >(new sparamOp<usedType>(*$2));
          tmpPtr = new Teuchos::RCP<astNode<usedType> >(*sparPtr);
          newExp.getSparamOpVec ().push_back(*sparPtr);
          delete sparPtr;
        }
        else if (firstArg[0] == 'Y')
        {
          Teuchos::RCP<yparamOp<usedType> > * yparPtr = new Teuchos::RCP<yparamOp<usedType> >(new yparamOp<usedType>(*$2));
          tmpPtr = new Teuchos::RCP<astNode<usedType> >(*yparPtr);
          newExp.getYparamOpVec ().push_back(*yparPtr);
          delete yparPtr;
        }
        else if (firstArg[0] == 'Z')
        {
          Teuchos::RCP<zparamOp<usedType> > * zparPtr = new Teuchos::RCP<zparamOp<usedType> >(new zparamOp<usedType>(*$2));
          tmpPtr = new Teuchos::RCP<astNode<usedType> >(*zparPtr);
          newExp.getZparamOpVec ().push_back(*zparPtr);
          delete zparPtr;
        }
        else
        {
          std::cout << "Unrecognized RF parameter: " << firstArg <<std::endl;
        }

        newExp.getMasterNodeVec().push_back(tmpPtr);

        // adjust for complex number variants
        // remove whitespace from the first argument
        if (firstArg.size() == 1)
        {
          returnPtr = tmpPtr;
        }
        else if (firstArg.size() == 2)
        {
           if ( firstArg[1] == 'R')
           {
             returnPtr = new Teuchos::RCP<astNode<usedType> >(new realOp<usedType>(*tmpPtr));
             newExp.getMasterNodeVec().push_back(returnPtr);
           }
           else if ( firstArg[1] == 'I')
           {
             returnPtr = new Teuchos::RCP<astNode<usedType> >(new imagOp<usedType>(*tmpPtr));
             newExp.getMasterNodeVec().push_back(returnPtr);
           }
           else if ( firstArg[1] == 'M')
           {
             returnPtr = new Teuchos::RCP<astNode<usedType> >(new absOp<usedType>(*tmpPtr));
             newExp.getMasterNodeVec().push_back(returnPtr);
           }
           else if ( firstArg[1] == 'P')
           {
             returnPtr = new Teuchos::RCP<astNode<usedType> >(new phaseOp<usedType>(*tmpPtr));
             newExp.getMasterNodeVec().push_back(returnPtr);
             newExp.getPhaseOpVec().push_back(*returnPtr);
           }
        }
        else if (firstArg.size() == 3) // do decibels here
        {
          if ( firstArg[1] == 'D' && firstArg[2] == 'B')
          {
            // this needs to implement 20.0*std::log10(abs(*tmpPtr))  
            Teuchos::RCP<astNode<usedType> > * numvalPtr = new Teuchos::RCP<astNode<usedType> >(new numval<usedType> (20.0));
            Teuchos::RCP<astNode<usedType> > * absPtr = new Teuchos::RCP<astNode<usedType> >(new absOp<usedType>(*tmpPtr));
            Teuchos::RCP<astNode<usedType> > * log10Ptr = new Teuchos::RCP<astNode<usedType> >(new log10Op<usedType>(*absPtr));
            returnPtr = new Teuchos::RCP<astNode<usedType> >(new binaryMulOp<usedType>  (*numvalPtr,*log10Ptr));

            newExp.getMasterNodeVec().push_back(numvalPtr);
            newExp.getMasterNodeVec().push_back(absPtr);
            newExp.getMasterNodeVec().push_back(log10Ptr);
            newExp.getMasterNodeVec().push_back(returnPtr);
          }
        }
        else
        {
          std::cout << "Unrecognized RF operator " << firstArg << std::endl;
        }
      }
      else
      {
        std::cout << "Wrong number of arguments to S-parameter !" <<std::endl;
      }

      $$ = returnPtr;
      delete $1;
      delete $2;
    }
  | TOK_LEAD TOK_CURRENTDEV
    {
      Teuchos::RCP<leadCurrentOp<usedType> > * leadCurrentPtr = new Teuchos::RCP<leadCurrentOp<usedType> >(new leadCurrentOp<usedType>(*$1,*$2));
      Teuchos::RCP<astNode<usedType> > * returnPtr = new Teuchos::RCP<astNode<usedType> >(*leadCurrentPtr);
      newExp.getLeadCurrentOpVec().push_back(*leadCurrentPtr);
      newExp.getMasterNodeVec().push_back(returnPtr);
      $$ = returnPtr;
      delete leadCurrentPtr;
      delete $1;
      delete $2;
    }
  | TOK_WORD TOK_INTERNAL_DEV_VAR
    {
      Teuchos::RCP<astNode<usedType> > * returnPtr;

      Teuchos::RCP<internalDevVarOp<usedType> > * internalDevVarPtr = new Teuchos::RCP<internalDevVarOp<usedType> >(new internalDevVarOp<usedType>(*$2));
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(*internalDevVarPtr);
      newExp.getMasterNodeVec().push_back(tmpPtr);
      newExp.getInternalDevVarOpVec().push_back(*internalDevVarPtr);

      // adjust for complex number variants
      std::string firstArg = (*$1);
      firstArg.erase(std::remove_if(firstArg.begin(),firstArg.end(), ::isspace), firstArg.end());
      if (firstArg.size() == 1)
      {
        returnPtr = tmpPtr;
      }
      else if (firstArg.size() == 2)
      {
         if ( firstArg == std::string("NR") )
         {
           returnPtr = new Teuchos::RCP<astNode<usedType> >(new realOp<usedType>(*tmpPtr));
           newExp.getMasterNodeVec().push_back(returnPtr);
         }
         else if ( firstArg == std::string("NI") )
         {
           returnPtr = new Teuchos::RCP<astNode<usedType> >(new imagOp<usedType>(*tmpPtr));
           newExp.getMasterNodeVec().push_back(returnPtr);
         }
         else if ( firstArg == std::string("NM") )
         {
           returnPtr = new Teuchos::RCP<astNode<usedType> >(new absOp<usedType>(*tmpPtr));
           newExp.getMasterNodeVec().push_back(returnPtr);
         }
         else if ( firstArg == std::string("NP") )
         {
           returnPtr = new Teuchos::RCP<astNode<usedType> >(new phaseOp<usedType>(*tmpPtr));
           newExp.getMasterNodeVec().push_back(returnPtr);
           newExp.getPhaseOpVec().push_back(*returnPtr);
         }
      }
      else if (firstArg.size() == 3) // do decibels here
      {
        if ( firstArg == std::string("NDB") )
        {
          // this needs to implement 20.0*std::log10(abs(*tmpPtr))  
          Teuchos::RCP<astNode<usedType> > * numvalPtr = new Teuchos::RCP<astNode<usedType> >(new numval<usedType> (20.0));
          Teuchos::RCP<astNode<usedType> > * absPtr = new Teuchos::RCP<astNode<usedType> >(new absOp<usedType>(*tmpPtr));
          Teuchos::RCP<astNode<usedType> > * log10Ptr = new Teuchos::RCP<astNode<usedType> >(new log10Op<usedType>(*absPtr));
          returnPtr = new Teuchos::RCP<astNode<usedType> >(new binaryMulOp<usedType>  (*numvalPtr,*log10Ptr));

          newExp.getMasterNodeVec().push_back(numvalPtr);
          newExp.getMasterNodeVec().push_back(absPtr);
          newExp.getMasterNodeVec().push_back(log10Ptr);
          newExp.getMasterNodeVec().push_back(returnPtr);
        }
      }
      else
      {
        std::cout << "Unrecognized internal variable operator " << firstArg << std::endl;
      }

      $$ = returnPtr;
      delete internalDevVarPtr;
      delete $1;
      delete $2;
    }
  | TOK_WORD nonempty_noise_device_list
    {
      Teuchos::RCP<astNode<usedType> > * returnPtr;
      std::string firstArg = (*$1);
      firstArg.erase(std::remove_if(firstArg.begin(),firstArg.end(), ::isspace), firstArg.end());

      if ( firstArg == std::string("DNO") )
      {
        Teuchos::RCP<dnoNoiseVarOp<usedType> > * dnoNoiseVarPtr = new Teuchos::RCP<dnoNoiseVarOp<usedType> >(new dnoNoiseVarOp<usedType>(*$2));
        returnPtr = new Teuchos::RCP<astNode<usedType> >(*dnoNoiseVarPtr);
        newExp.getMasterNodeVec().push_back(returnPtr);
        newExp.getDnoNoiseDevVarOpVec().push_back(*dnoNoiseVarPtr);
        delete dnoNoiseVarPtr;
      }
      else if ( firstArg == std::string("DNI") )
      {
        Teuchos::RCP<dniNoiseVarOp<usedType> > * dniNoiseVarPtr = new Teuchos::RCP<dniNoiseVarOp<usedType> >(new dniNoiseVarOp<usedType>(*$2));
        returnPtr = new Teuchos::RCP<astNode<usedType> >(*dniNoiseVarPtr);
        newExp.getMasterNodeVec().push_back(returnPtr);
        newExp.getDniNoiseDevVarOpVec().push_back(*dniNoiseVarPtr);
        delete dniNoiseVarPtr;
      }

      $$ = returnPtr;
      delete $1;
      delete $2;
    }
  | TOK_ONOISE
    {
      Teuchos::RCP<oNoiseOp<usedType> > * onoisePtr = new Teuchos::RCP<oNoiseOp<usedType> >(new oNoiseOp<usedType>());
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(*onoisePtr);
      newExp.getONoiseOpVec().push_back(*onoisePtr);
      newExp.getMasterNodeVec().push_back(tmpPtr);
      $$ = tmpPtr;
      delete $1;
      delete onoisePtr;
    }
  | TOK_INOISE
    {
      Teuchos::RCP<iNoiseOp<usedType> > * inoisePtr = new Teuchos::RCP<iNoiseOp<usedType> >(new iNoiseOp<usedType>());
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(*inoisePtr);
      newExp.getINoiseOpVec().push_back(*inoisePtr);
      newExp.getMasterNodeVec().push_back(tmpPtr);
      $$ = tmpPtr;
      delete $1;
      delete inoisePtr;
    }

  | TOK_MAX  TOK_LEFTPAREN exp ',' exp TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new maxOp<usedType>(*$3,*$5));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_MIN  TOK_LEFTPAREN exp ',' exp TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new minOp<usedType>(*$3,*$5));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_POWER TOK_CURRENTDEV
    {
      Teuchos::RCP<powerOp<usedType> > * powerPtr = new Teuchos::RCP<powerOp<usedType> >(new powerOp<usedType>(*$2));
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(*powerPtr);
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
      newExp.getPowerOpVec().push_back(*powerPtr);
      delete $1;
      delete $2;
      delete powerPtr;
    }
  | TOK_PHASE exp TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new phaseOp<usedType>(*$2));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
      newExp.getPhaseOpVec().push_back(*tmpPtr);
    }
  | TOK_REAL exp TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new realOp<usedType>(*$2));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_IMAG TOK_LEFTPAREN exp TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new imagOp<usedType>(*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_SQRT TOK_LEFTPAREN exp TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new sqrtOp<usedType>(*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_EXP TOK_LEFTPAREN exp TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new expOp<usedType>(*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_SIN TOK_LEFTPAREN exp TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new sinOp<usedType>(*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_COS TOK_LEFTPAREN exp TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new cosOp<usedType>(*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_MABS exp TOK_RIGHTPAREN 
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new absOp<usedType>(*$2));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_ABS TOK_LEFTPAREN exp TOK_RIGHTPAREN 
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new absOp<usedType>(*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_ACOS TOK_LEFTPAREN exp TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new acosOp<usedType>(*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_ACOSH TOK_LEFTPAREN exp TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new acoshOp<usedType>(*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_ASIN TOK_LEFTPAREN exp TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new asinOp<usedType>(*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_ASINH TOK_LEFTPAREN exp TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new asinhOp<usedType>(*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_ATAN2 TOK_LEFTPAREN exp ',' exp TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new atan2Op<usedType>(*$3,*$5));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_ATAN TOK_LEFTPAREN exp TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new atanOp<usedType>(*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_ATANH TOK_LEFTPAREN exp TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new atanhOp<usedType>(*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }

  | TOK_COSH TOK_LEFTPAREN exp TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new coshOp<usedType>(*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_LN TOK_LEFTPAREN exp TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new logOp<usedType>(*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_LOG TOK_LEFTPAREN exp TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new log10Op<usedType>(*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_LOG10 TOK_LEFTPAREN exp TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new log10Op<usedType>(*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_SINH TOK_LEFTPAREN exp TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new sinhOp<usedType>(*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_TAN TOK_LEFTPAREN exp TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new tanOp<usedType>(*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_TANH TOK_LEFTPAREN exp TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new tanhOp<usedType>(*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_CEIL TOK_LEFTPAREN exp TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new ceilOp<usedType>(*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_FLOOR TOK_LEFTPAREN exp TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new floorOp<usedType>(*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_INT   TOK_LEFTPAREN exp TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new intOp<usedType>(*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_LIMIT TOK_LEFTPAREN exp ',' exp TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new twoArgLimitOp<usedType>(*$3,*$5));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_LIMIT TOK_LEFTPAREN exp ',' exp ',' exp TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new limitOp<usedType>(*$3,*$5,*$7));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_STP TOK_LEFTPAREN exp TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new stpOp<usedType>(*$3));
      $$ = tmpPtr;
      newExp.getStpNodeVec().push_back(*tmpPtr);
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_URAMP TOK_LEFTPAREN exp TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new urampOp<usedType>(*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
   | TOK_POLY  TOK_POLYSIZE no_comma_arglist no_comma_coeflist
    {

      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new polyOp<usedType>($2,$3,$4));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
      delete $3;
      delete $4;
    }
  | TOK_TABLE TOK_LEFTPAREN TOK_LEFTCURLYBRACE exp TOK_RIGHTCURLYBRACE '=' nonempty_arglist TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new tableOp<usedType>(*$4,$7));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
      if ( (*$4)->timeSpecialType() ) 
      {
        newExp.getSrcNodeVec().push_back(*tmpPtr);
        newExp.setTimeDependent(true); 
      }

      delete $7;
    }
  | TOK_TABLE TOK_LEFTPAREN TOK_LEFTCURLYBRACE exp TOK_RIGHTCURLYBRACE nonempty_arglist TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new tableOp<usedType>(*$4,$6));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
      if ( (*$4)->timeSpecialType() )
      {
        newExp.getSrcNodeVec().push_back(*tmpPtr);
        newExp.setTimeDependent(true); 
      }
      delete $6;
    }
  | TOK_TABLE TOK_LEFTPAREN exp ',' nonempty_arglist TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new tableOp<usedType>(*$3,$5));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
      if ( (*$3)->timeSpecialType() )
      {
        newExp.getSrcNodeVec().push_back(*tmpPtr);
        newExp.setTimeDependent(true); 
      }
      delete $5;
    }
  | TOK_TABLE TOK_LEFTPAREN exp ',' nonempty_arglist ',' TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new tableOp<usedType>(*$3,$5));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
      if ( (*$3)->timeSpecialType() )
      {
        newExp.getSrcNodeVec().push_back(*tmpPtr);
        newExp.setTimeDependent(true); 
      }
      delete $5;
    }
  | TOK_TABLE TOK_LEFTPAREN exp ',' '=' nonempty_arglist TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new tableOp<usedType>(*$3,$6));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
      if ( (*$3)->timeSpecialType() ) 
      {
        newExp.getSrcNodeVec().push_back(*tmpPtr);
        newExp.setTimeDependent(true); 
      }
      delete $6;
    }
  | TOK_TABLE TOK_LEFTCURLYBRACE exp TOK_RIGHTCURLYBRACE nonempty_arg_pairs 
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new tableOp<usedType>(*$3,$5));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
      if ( (*$3)->timeSpecialType() )
      {
        newExp.getSrcNodeVec().push_back(*tmpPtr);
        newExp.setTimeDependent(true); 
      }
      delete $5;
    }
  | TOK_TABLE TOK_LEFTCURLYBRACE exp TOK_RIGHTCURLYBRACE '=' nonempty_arg_pairs 
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new tableOp<usedType>(*$3,$6));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
      if ( (*$3)->timeSpecialType() )
      {
        newExp.getSrcNodeVec().push_back(*tmpPtr);
        newExp.setTimeDependent(true); 
      }
      delete $6;
    }
  | TOK_TABLE TOK_LEFTCURLYBRACE exp TOK_RIGHTCURLYBRACE nonempty_arglist 
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new tableOp<usedType>(*$3,$5));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
      if ( (*$3)->timeSpecialType() )
      {
        newExp.getSrcNodeVec().push_back(*tmpPtr);
        newExp.setTimeDependent(true); 
      }
      delete $5;
    }
  | TOK_SCHEDULE TOK_LEFTPAREN nonempty_arglist TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > tmpPtr2 = newExp.getTimeNode();
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new scheduleOp<usedType>($3, tmpPtr2));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
      newExp.getSrcNodeVec().push_back(*tmpPtr);
      newExp.setTimeDependent(true);
      delete $3;
    }
  | TOK_SDT  TOK_LEFTPAREN exp TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > timeNode = newExp.getTimeNode();
      Teuchos::RCP<astNode<usedType> > dtNode = newExp.getDtNode();
      Teuchos::RCP<astNode<usedType> > * sdtPtr = new Teuchos::RCP<astNode<usedType> >(new sdtOp<usedType>(*$3, dtNode, timeNode));
      $$ = sdtPtr;
      newExp.getMasterNodeVec().push_back(sdtPtr);
      newExp.getSdtOpVec().push_back(*sdtPtr);
      newExp.setTimeDependent(true);
    }
  | TOK_DDT  TOK_LEFTPAREN exp TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > timeNode = newExp.getTimeNode();
      Teuchos::RCP<astNode<usedType> > dtNode = newExp.getDtNode();
      Teuchos::RCP<astNode<usedType> > * ddtPtr = new Teuchos::RCP<astNode<usedType> >(new ddtOp<usedType>(*$3, dtNode, timeNode));
      $$ = ddtPtr;
      newExp.getMasterNodeVec().push_back(ddtPtr);
      newExp.getDdtOpVec().push_back(*ddtPtr);
      newExp.setTimeDependent(true);
    }
  | TOK_DDX  TOK_LEFTPAREN exp ',' exp TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new ddxOp<usedType>(*$3,*$5));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_AGAUSS TOK_LEFTPAREN exp ',' exp ',' exp TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new agaussOp<usedType>(*$3,*$5,*$7));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_GAUSS TOK_LEFTPAREN exp ',' exp ',' exp TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new gaussOp<usedType>(*$3,*$5,*$7));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_AUNIF TOK_LEFTPAREN exp ',' exp  TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new aunifOp<usedType>(*$3,*$5));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_UNIF TOK_LEFTPAREN exp ',' exp TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new unifOp<usedType>(*$3,*$5));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_RAND TOK_LEFTPAREN TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new randOp<usedType>());
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }

 /* SPICE time-dependent sources.  These have optional length argument lists */
 /* pulse( v1,v2,td,tr,tf,pw,per) */
  | TOK_SPICE_PULSE TOK_LEFTPAREN nonempty_arglist TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > tmpPtr2 = newExp.getTimeNode();
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new spicePulseOp<usedType>($3, tmpPtr2 ));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
      newExp.getSrcNodeVec().push_back(*tmpPtr);
      newExp.setTimeDependent(true);
      delete $3;
    }
 /* sin (v0,va,frequency,td,theta,phase) */
  | TOK_SPICE_SIN   TOK_LEFTPAREN nonempty_arglist TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > tmpPtr2 = newExp.getTimeNode();
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new spiceSinOp<usedType>($3, tmpPtr2 ));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
      newExp.getSrcNodeVec().push_back(*tmpPtr);
      newExp.setTimeDependent(true);
      delete $3;
    }
 /* exp ( v1,v2,td1,tau1,td2,tau2) */
  | TOK_SPICE_EXP   TOK_LEFTPAREN nonempty_arglist TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > tmpPtr2 = newExp.getTimeNode();
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new spiceExpOp<usedType>($3,tmpPtr2));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
      newExp.getSrcNodeVec().push_back(*tmpPtr);
      newExp.setTimeDependent(true);
      delete $3;
    }
 /* sffm (v0,va,fc,mdi,fs) */
  | TOK_SPICE_SFFM   TOK_LEFTPAREN nonempty_arglist TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > tmpPtr2 = newExp.getTimeNode();
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new spiceSffmOp<usedType>($3,tmpPtr2));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
      newExp.setTimeDependent(true);
      delete $3;
    }

  | exp '?' exp ':' exp
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new ifStatementOp<usedType>((*$1),(*$3),(*$5)));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_IF TOK_LEFTPAREN exp ',' exp ',' exp TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new ifStatementOp<usedType>((*$3),(*$5),(*$7)));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }

  | exp TOK_EQ exp
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new eqOp<usedType>(*$1,*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
      newExp.getCompNodeVec().push_back(*tmpPtr);
    }
  | exp TOK_NE exp
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new neOp<usedType>(*$1,*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
      newExp.getCompNodeVec().push_back(*tmpPtr);
    }
  | exp TOK_GT exp
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new gtOp<usedType>(*$1,*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
      newExp.getCompNodeVec().push_back(*tmpPtr);
    }
  | exp TOK_LT exp
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new ltOp<usedType>(*$1,*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
      newExp.getCompNodeVec().push_back(*tmpPtr);
    }
  | exp TOK_GE exp
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new geOp<usedType>(*$1,*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
      newExp.getCompNodeVec().push_back(*tmpPtr);
    }
  | exp TOK_LE exp
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new leOp<usedType>(*$1,*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
      newExp.getCompNodeVec().push_back(*tmpPtr);
    }
  | exp TOK_OR exp
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new orOp<usedType>(*$1,*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | exp TOK_AND exp
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new andOp<usedType>(*$1,*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | exp TOK_XOR exp
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new xorOp<usedType>(*$1,*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_NOT exp
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new unaryNotOp<usedType>(*$2));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  ;

nonempty_rfparam_arg_list: TOK_RFPARAM_ARG { $$ = new std::vector<int>; $$->push_back($1); }
  | nonempty_rfparam_arg_list  TOK_RFPARAM_ARG  { $$->push_back($2); }

nonempty_noise_device_list: TOK_NOISE_DEV_VAR { $$ = new std::vector< std::string >; $$->push_back(*($1)); delete $1; }
  | nonempty_noise_device_list  TOK_NOISE_DEV_VAR  { $$->push_back(*($2)); delete $2; }

nonempty_voltagenodelist: TOK_VOLTAGENODE { $$ = new std::vector< std::string >; $$->push_back(*($1)); delete $1; }
  | nonempty_voltagenodelist  TOK_VOLTAGENODE  { $$->push_back(*($2)); delete $2; }

nonempty_arglist: exp         { $$ = new std::vector< Teuchos::RCP<astNode<usedType> > >(1,*$1); }
  | nonempty_arglist ','  exp { $$->push_back((*$3)); }

nonempty_arg_pairs: TOK_LEFTPAREN exp ',' exp TOK_RIGHTPAREN  { $$ = new std::vector< Teuchos::RCP<astNode<usedType> > >(1,*$2);  $$->push_back((*$4));  } 
  | nonempty_arg_pairs TOK_LEFTPAREN exp ',' exp TOK_RIGHTPAREN  { $$->push_back((*$3)); $$->push_back((*$5)); }

no_comma_arglist: exp         { $$ = new std::vector< Teuchos::RCP<astNode<usedType> > >(1,*$1);  }
  | no_comma_arglist  exp { $$->push_back((*$2)); }

no_comma_coeflist:  paren_polycoef         { 
      Teuchos::RCP<astNode<usedType> > *tmpPtr = new Teuchos::RCP<astNode<usedType> >(new numval<usedType>($1));
      $$ = new std::vector< Teuchos::RCP<astNode<usedType> > >(1,*tmpPtr);  
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  |  no_comma_coeflist  paren_polycoef{ 
      Teuchos::RCP<astNode<usedType> > *tmpPtr = new Teuchos::RCP<astNode<usedType> >(new numval<usedType>($2));
      $$->push_back((*tmpPtr)); 
      newExp.getMasterNodeVec().push_back(tmpPtr);
     }

paren_polycoef: TOK_POLYCOEF
     {
       $$ = $1;
     }
  | TOK_LEFTPAREN paren_polycoef TOK_RIGHTPAREN
    {
       $$ = $2;
    }
  | TOK_LEFTCURLYBRACE paren_polycoef TOK_RIGHTCURLYBRACE
    {
       $$ = $2;
    }

%%

int XyceExpressionlex(XyceExpression::ExpressionParser::semantic_type *lvalp, XyceExpression::location *locp,
                  Xyce::Util::ExpressionLexer *theLexer)
{
        return(theLexer->getToken(lvalp,locp));
}

void
XyceExpression::ExpressionParser::error(
  const XyceExpression::ExpressionParser::location_type & l,
  const std::string &                               message)
{
  //Xyce::Report::UserError().at(theLexer->netlistLocation_)
 std::cout << "ERROR!!! " << message << " in expression " << newExp.getExpressionString() << std::endl;
}
